############# Alertas #############
1) Sempre que a porquice do sklearn exigir setar random_state globalmente,
    precisamos fazer isso imediatamente antes da chamada que uso o gerador de números.
    Exemplo SelectKBest com mutual_info_classif.
    É impossível setar o random_state do mutual_info_classif, sem ser globalmente.

############# Prioridades #############
1) Fazer o pai dos Transformers [DONE]

2) Criar modulo proprio para o Sklean []

3) Arrumar ConfigLess1 e ConfigLess2 [Done]

4) Ressuscitar o Random AutoML [Done]

5) Historico []

6) Cache []

7) Por que a msg de erro
    'AttributeError: type object 'NoData' has no attribute 'Xt''
    aparece em vez de
    'NoData is not accepted by Binarize'?

8a) Incluir seed nos componentes [done]
8b) Incluir seed nos redutores de CS (rnd, ...) [ ]

9) Resolver problema do tempo (matar pipeline que passar o tempo permitido)

10) Definir parametros default nos Param do CS

11) Injetar valores default no config durante init quando usuário não prover alguns parâmetros

12) Probabilidade dos nós do CS
    SelectCS(A, B, C, probs=[0.2, 0.35, 0.45])   # probs ou P ou ...?
    Node(children=[A, B, C], probs=[0.2, 0.35, 0.45])
    ConfigList(A, B, C, probs=[0.2, 0.35, 0.45])

    def choice(items, probs=None):
        ...

13a) Remover parametros sem sentido do config [done]
    Split, Partition

13b) Fazer o mesmo para todos componentes especialmente quando defaults forem injetados?

14) Fazer mapa de hints para ir junto com falha de pipeline (failure={'message':'sdfsdf', 'hint':'dsffgg'})

15) Ressuscitar a PyMFE

16) AutoML baseado em programação genética.

17) Incluir versão no config

############# Ideias futuras #############

1) Definir importancia/sensibilidade de parâmetros

2) Temos CS de parametros que afetam acurácia. Poderemos ter outro CS, com parâmetros que afetam apenas(?) tempo ou memória?
    n_estimators do RF: quanto menor mais rápido; qto maior mais preciso; poderia haver uma sugestão de direção em cada Param

3) Possibilitar use() de componentes Light (sem gerar modelo / sem apply):
    data = File("abalone3.arff").use()

4) Casca imperativa em cima do funcional.
    Funcional:
        model = transf.apply(...)
        result = model.use(...)
    Mutável:
        transf.apply(...)
        result = transf.use(...)
    Funcionamento: transf mantém referência para o último Model gerado; LightTransformers ignoram pois não precisam de modelo.

5) Pessoalmente prefiro apply(), mas seria fit() mais palatável ao público geral? Fazer congresso Pajé para ver reação à API?

6) Um IC poderia fazer um "ipython" pra rodar o pjml e parsear a saída de texto para collapsar/expandir o modo prettyprinting com o mouse.

########################## Apêndice ###############################

1)
    UUID Proof:
    APPLY  D    --> T1     --> D1, M1      --> T2        --> D2, M2
           (d)  --> (t1)   --> (d+t1)      --> (t1)      --> (d+t1+t2)
    USE    D'   --> M1     --> D'1         --> M2        --> D'2
           (d') --> (d+t1) --> (d'+d+t1)   --> (d+t1+t2) --> (d'+d+t1+d+t1+t2)
           (d') --> (m1)   --> (d'+m1)     --> (m1+t2) --> (d'+m1+m1+t2)
           (d') --> (m1)   --> (d'+m1)     --> (m2)    --> (d'+m1+m2)

    LightTransformer: USE análogo a APPLY