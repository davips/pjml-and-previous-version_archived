############# Alertas #############
1) Sempre que a porquice do sklearn exigir setar random_state globalmente,
    precisamos fazer isso imediatamente antes da chamada que uso o gerador de números.
    Exemplo SelectKBest com mutual_info_classif.
    É impossível setar o random_state do mutual_info_classif, sem ser globalmente.

############# Prioridades #############
1) Fazer o pai dos Transformers [DONE]

2) Criar modulo proprio para o Sklean []

3) Arrumar ConfigLess1 e ConfigLess2 [Done]

4) Ressuscitar o Random AutoML [Done]

5) Historico []

6) Cache []

7) Por que a msg de erro
    'AttributeError: type object 'NoData' has no attribute 'Xt''
    aparece em vez de
    'NoData is not accepted by Binarize'?

8) Incluir seed e versão no config

9) Resolver problema do tempo (matar pipeline que passar o tempo permitido)

10) Definir parametros default no CS e injetá-los no config durante init quando necessário

11) Probabilidade dos nós do CS
    SelectCS(A, B, C, probs=[0.2, 0.35, 0.45])   # probs ou P ou ...?
    Node(children=[A, B, C], probs=[0.2, 0.35, 0.45])
    ConfigList(A, B, C, probs=[0.2, 0.35, 0.45])

    def choice(items, probs=None):
        ...

12) Remover parametros inuteis do config (ex. 'test_size' junto com 'cv')

13) Fazer mapa de hints para ir junto com falha de pipeline (failure={'message':'sdfsdf', 'hint':'dsffgg'})

14) Ressuscitar a PyMFE

15) AutoML baseado em programação genética.



############# Ideias futuras #############

1) Definir importancia/sensibilidade de parâmetros

2) Temos CS de parametros que afetam acurácia. Poderemos ter outro CS, com parâmetros que afetam apenas(?) tempo ou memória?
    n_estimators do RF: quanto menor mais rápido; qto maior mais preciso; poderia haver uma sugestão de direção em cada Param

3) Possibilitar use() de componentes Light (sem gerar modelo / sem apply):
    data = File("abalone3.arff").use()

4) Casca imperativa em cima do funcional.
    Funcional:
        model = transf.apply(...)
        result = model.use(...)
    Mutável:
        transf.apply(...)
        result = transf.use(...)
    Funcionamento: transf mantém referência para o último Model gerado; LightTransformers ignoram pois não precisam de modelo.

5) Pessoalmente prefiro apply(), mas seria fit() mais palatável ao público geral? Fazer congresso Pajé para ver reação à API?



########################## Apêndice ###############################

1)
    UUID Proof:
    APPLY  D    --> T1     --> D1, M1      --> T2        --> D2, M2
           (d)  --> (t1)   --> (d+t1)      --> (t1)      --> (d+t1+t2)
    USE    D'   --> M1     --> D'1         --> M2        --> D'2
           (d') --> (d+t1) --> (d'+d+t1)   --> (d+t1+t2) --> (d'+d+t1+d+t1+t2)
           (d') --> (m1)   --> (d'+m1)     --> (m1+t2) --> (d'+m1+m1+t2)
           (d') --> (m1)   --> (d'+m1)     --> (m2)    --> (d'+m1+m2)

    LightTransformer: USE análogo a APPLY